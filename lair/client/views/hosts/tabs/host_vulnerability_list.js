Template.hostVulnerabilityList.helpers({
    projectId: function () {
        return Session.get('projectId');
    },
    flagFilter: function () {
        return Session.get('vulnerabilityListFlagFilter');
    },
    vulnerabilities: function () {
        var projectId = Session.get('projectId');
        var hostId = Session.get('hostId');
        var host = Hosts.findOne(hostId);
        if (!host) {
            return false;
        }
        var query = {
            project_id: projectId,
            'hosts.string_addr': host.string_addr,
            status: {
                $in: []
            }
        };
        if (Session.equals('vulnerabilityListFlagFilter', 'enabled')) {
            query.flag = true;
        }
        if (!Session.equals('vulnerabilityListStatusButtongrey', 'disabled')) {
            query.status.$in.push('lair-grey');
        }
        if (!Session.equals('vulnerabilityListStatusButtonblue', 'disabled')) {
            query.status.$in.push('lair-blue');
        }
        if (!Session.equals('vulnerabilityListStatusButtongreen', 'disabled')) {
            query.status.$in.push('lair-green');
        }
        if (!Session.equals('vulnerabilityListStatusButtonorange', 'disabled')) {
            query.status.$in.push('lair-orange');
        }
        if (!Session.equals('vulnerabilityListStatusButtonred', 'disabled')) {
            query.status.$in.push('lair-red');
        }
        var search = Session.get('vulnerabilitySearch');
        if (search) {
            query.$or = [{
                cvss: {
                    $regex: search,
                    $options: 'i'
                }
            }, {
                title: {
                    $regex: search,
                    $options: 'i'
                }
            }, {
                last_modified_by: {
                    $regex: search,
                    $options: 'i'
                }
            }];
        }

        // search through a returned list of vulnerabilities, returning a list of
        // only those that match the selected host. additionally, add the port and protocol.
        // remove_string is a probably not so clever hack to handle deletion of vulnerabilities,
        // it creates a string of id-string_addr-port-protocol which is later split up into an array
        var vulnerabilityWithPortList = [];
        Vulnerabilities.find(query, {
            sort: {
                cvss: -1,
                title: 1
            }
        }).fetch().forEach(function (vulnerability) {
            vulnerability.hosts.forEach(function (h) {
                if (h.string_addr === host.string_addr) {
                    var portId = Ports.findOne({
                        project_id: projectId,
                        host_id: hostId,
                        port: h.port,
                        protocol: h.protocol
                    })._id;
                    vulnerabilityWithPortList.push({
                        _id: vulnerability._id,
                        title: vulnerability.title,
                        cvss: vulnerability.cvss,
                        status: vulnerability.status,
                        port: h.port,
                        protocol: h.protocol,
                        portId: portId,
                        remove_string: [vulnerability._id, h.string_addr, h.port, h.protocol].join('-')
                    });
                }
            });
        });
        vulnerabilityWithPortList.forEach(addVulnRating);
        return vulnerabilityWithPortList;
    },
    searchTerm: function () {
        return Session.get('vulnerabilitySearch');
    },
    vulnerabilityListStatusButtonActive: function (status) {
        if (Session.equals('vulnerabilityListStatusButton' + status, 'disabled')) {
            return 'disabled';
        }
        return false;
    }
});


Template.hostVulnerabilityList.events({
    'click #flag-filter-enable': function () {
        return Session.set('vulnerabilityListFlagFilter', 'enabled');
    },

    'click #flag-filter-disable': function () {
        return Session.set('vulnerabilityListFlagFilter', null);
    },

    'click .vulnerability-status-button': function (event) {
        var id = 'vulnerabilityListStatusButton' + event.target.id;
        if (Session.equals(id, null)) {
            return Session.set(id, 'disabled');
        }
        return Session.set(id, null);
    },

    'keyup #vulnerability-list-search': function (event, tpl) {
        Session.set('vulnerabilitySearch', escapeRegex(tpl.find('#vulnerability-list-search').value));
    },

    'click #remove-vulnerabilities': function () {
        var projectId = Session.get('projectId');
        var vulnerabilityIds = [];
        var inputs = $('.vulnerability-checked');
        inputs.each(function () {
            if ($(this).is(':checked')) {
                vulnerabilityIds.push($(this).attr('id'));
            }
        });
        vulnerabilityIds.forEach(function (id) {
            var data = id.split('-');
            Meteor.call('removeHostFromVulnerability', projectId, data[0], data[1], parseInt(data[2]), data[3]);
        });
    }
});
